<?php

//1
/* git update-index --assume-unchanged имя_файла = делает изменения в этом файле невидимыми для git,
 но оставляет его в репозитории*/

//2
/* git update-index --no-assume-unchanged имя_файла = отменяет предыдущую
команду(git update-index --assume-unchanged имя_файла)*/

//3
// git commit --amend = Перезаписывает последний коммит
// git commit --amend -m "комментарий" = перезаписывает комментарий к последнему коммиту
// git commit --amend --no-edit = добавляет в последний коммит новые изменения, не меняя название
// git commit --amend --author="Новый автор" = перезаписывает нового автора в последний коммит

//4
/* git clone Путь/до/копируемого/репозитория
название_папки_в_текущем_репозитории,_в_которую_нужно_скопировать = копирует репозиторий*/
/* git clone -d название_ветки --single-branch Путь/до/копируемого/репозитория
 название_папки_в_текущем_репозитории,_в_которую_нужно_скопировать = копирует из
репозитория только выбранную ветку*/
/*git clone Путь/до/копируемого/репозитория --depth=число_последних_коммитов_в_истории
название_папки_в_текущем_репозитории,_в_которую_нужно_скопировать = копирует
репозиторий с урезанной историей*/

//5
/* git branch название_новой_ветки = создаёт новую ветку*/
/* git branch = показывает все локальные ветки*/
/* git branch -r = показывает все ремоутные ветки*/
/* git branch -a = показывает вообще все доступные ветки
/* git branch -d название_ветки = удаляет выбранную ветку
/* git branch -D название_ветки = удаляет выбранную ветку не смотря ни на что*/


//6
/* git fetch = показывает все внешние ветки*/

//7
/* git remote prune origin = Удаление с локального
репозитория всех заремоученых веток, которые были удалены на внешнем репозитории*/

//8
/* git push origin :название_ветки = удаляет ветку на внешнем репозитории,
 подчищая её и на локали (называется это "прун")*/

//9
/* git reset --hard = удаляет все изменения до последнего коммита, но не трогает антрэкт-файлы*/

//10
/* git clean -n = показывает те файлы, которые будут удалены*/
/* git clean -f = удаляет антрэкт-файлы показанные в git clean -n*/
/* git clean -n -d = показывает те файлы и дериктории, которые будут удалены*/
/* git clean -f -d = удаляет антрактс-файлы и дериктории показанные в git clean -n -d*/

//11
/* git stash = сохранение изменений без из добавления в коммит*/
/* git stash list = выводит список сташей*/
/* git stash apply id_нужного_сташа(если не указать, выберестя последний) = "возвращает к
жизни" все изменения из выбранного сташа*/
/* git stash pop = "возвращает к жизни" последний элемент сташа*/
/* git stash save "Название_сташа" = сохранение изменений без из
добавления в коммит под определённы именем*/
/* git stash -u = сохранение в сташ файлов не добавленных в GIT*/
/* git stash -a = сохранение в сташ всех файлов изменений, даже невидимых для GIT (даже те,
что находятся в git ignore)*/

//12
/* git log --oneline = показывает историю коммитов с их хешами*/

//13
/* git show хеш_коммита = показывает историю изменений выбранного коммита*/

//14
/* git reset --mixed(этот флаг можно не указывать, он идёт по умолчанию) хеш_коммита = отменяет коммит и
индексирование до указанного коммита
(если была допущена ошипка при вводе хеша, можно сделать откат в "будущее",
чтобы не потерять свои наработки. Ошибка обратима.)*/
/* git reset --soft хеш_коммита = отменяет коммит, но не индекс и изменения в нём*/
/* git reset --hard хеш_коммита = удаляет все изменения до указанного коммита*/

//15
/* Название_нужной_ветки = добавляет в текущую ветку коммиты
из выбранной ветки(ветки предак текущей), упакованные в 1 коммит. История не меняется.*/

//16
/* git rebase Название_нужной_ветки = добавляет в текущую ветку все коммиты выбранной
ветки(ветки предак текущей), в хронологическом
порядке(все коммиты текущей ветки ставятся после добавленных)). История меняется.*/

//17
/* git rebase -i название_ветки = вызов интерактивного rebase*/
/* git rebase -i HEAD~нужное_число_коммитов = изменение истории выбраного количества
 последних коммитов текущей ветки*/
/* git push origin название_текущей_ветки --force / git push origin +название_текущей_ветки =
форс-пуш изменённой ветки на удалённый репозиторий*/
/* git commit --fixup=хеш_нужного_коммита = подклейка изменений к выбранному коммиту*/
/* git rebase -i --autosquash HEAD~3 = изменение истории выбраного количества
 последних коммитов текущей ветки, при этом последний коммит подклеивается к предыдущему*/
/* git rebase -i название_нужной_ветки = настройка добавление к текущей ветке
 коммитов из родительской ветки и настройка коммитов в текущей ветке*/

//18
/* git checkout название(-я)_нужного(-ных)_файла(-ов) = Откатывает изменения в
 выбранных файлах (может вернуть удалённые файлов)*/

//19
/* git revert хеш_нужного_коммита = создаёт коммит удаляя все изменения сделанные
в выбранном коммите(исползуется, если выбранный коммит запушен на сервер
и использование --amend невозможно)*/

//20
/* git cherry-pick хеш_нужного_коммита = перемещают в текущую
ветку выбранный коммит из другой ветки*/
/* git cherry-pick хеш_нужного_коммита -edit = тоже что и git cherry-pick
хеш_нужного_коммита, но задаётся новый месседж переносимого коммита*/
/* git cherry-pick хеш_нужного_коммита --no-commit = тоже что и git cherry-pick
хеш_нужного_коммита, но изменения из переносимого коммита перемещаются не в новый коммит,
а в рабочую директорию без коммитирования*/